<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HackerNews Clustered, 2025 Edition</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#0a0a0a;color:#e0e0e0;overflow:hidden}
  #container{display:flex;height:100vh}
  #sidebar{width:320px;background:#1a1a1a;border-right:1px solid #333;overflow-y:auto;padding:20px;flex-shrink:0}
  #canvas-container{flex:1;position:relative;display:flex;flex-direction:column}
  canvas{display:block;cursor:grab;flex:1;background:#070707}
  canvas:active{cursor:grabbing}
  h1{font-size:24px;margin-bottom:10px;color:#ff6600}
  .stats{font-size:13px;color:#888;margin-bottom:20px;padding-bottom:15px;border-bottom:1px solid #333}
  .cluster-list{display:flex;flex-direction:column;gap:8px}
  .cluster-item{padding:12px;background:#252525;border-radius:6px;cursor:pointer;transition:all .15s;border:2px solid transparent}
  .cluster-item:hover{background:#2a2a2a;transform:translateX(4px)}
  .cluster-item.active{border-color:#ff6600;background:#2a2a2a}
  .cluster-name{font-weight:600;font-size:14px;margin-bottom:4px}
  .cluster-count{font-size:12px;color:#888}
  .loading{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:18px;color:#888}
  .controls{position:absolute;top:20px;right:20px;background:rgba(26,26,26,0.95);padding:12px;border-radius:8px;border:1px solid #333}
  .controls button{display:block;width:100%;padding:10px;margin-bottom:8px;background:#252525;color:#e0e0e0;border:1px solid #444;border-radius:4px;cursor:pointer;font-size:13px}
  .controls button:hover{background:#2a2a2a}
  .debug-info{position:absolute;bottom:20px;right:20px;background:rgba(26,26,26,0.95);padding:10px 15px;border-radius:8px;border:1px solid #333;font-size:11px;color:#888}
  #tooltip{position:absolute;background:rgba(0,0,0,0.95);color:#fff;padding:10px 14px;border-radius:4px;font-size:13px;pointer-events:auto;display:none;max-width:420px;border:1px solid #444;z-index:1000;line-height:1.4}
  #tooltip a{color:#ff6600;text-decoration:none;display:block;margin-top:6px;font-size:11px}
  #tooltip.pinned{border-color:#ff6600}
  .color-swatch{display:inline-block;width:12px;height:12px;border-radius:2px;margin-right:6px;vertical-align:middle}
</style>
</head>
<body>
<div id="container">
  <div id="sidebar">
    <h1>HN Clustered 2025</h1>
    <div class="stats" id="stats">Loading...</div>
    <div class="cluster-list" id="cluster-list"></div>
  </div>

  <div id="canvas-container">
    <div class="loading" id="loading">Loading data...</div>
    <canvas id="canvas"></canvas>
    <div class="controls">
      <button id="resetBtn">Reset View</button>
      <button id="showAllBtn">Show All</button>
      <button id="forceBtn">Force Re-render</button>
    </div>
    <div class="debug-info" id="debug-info"></div>
  </div>
</div>

<div id="tooltip"></div>

<script>
/* ========== CONFIG ========== */
const DPR = Math.max(1, window.devicePixelRatio || 1);
const MAX_RASTER_DIM = 4096;          // max pixels (width/height) to avoid OOM
const MIN_RASTER_DIM = 256;
const RASTER_PAD = 2.0;               // raster covers viewport * RASTER_PAD (large to avoid re-renders)
const ZOOM_RENDER_THRESHOLD = 1.25;   // re-render if current ppwu > raster.ppwu * threshold
const ZOOM_FACTOR_THRESHOLD = 1.35;   // re-render if zoom changes relative to raster.createdAtZoom
const RASTER_DEBOUNCE_MS = 120;       // debounce raster creation
const VISIBLE_POINTS_CAP = 350000;    // safety cap for drawing
const HOVER_SEARCH_CAP = 100000;      // cap how many points we iterate for hover (safety)
const HOVER_THRESHOLD_PX = 10;        // pixels for nearest hover

// Dot sizing constants
const DOT_FRACTION = 0.22;   // fraction of avg pixel spacing used for dot size (tweakable)
const DOT_MIN_PX = 1;        // minimum visible dot radius/pixel size
const DOT_MAX_PX = 14;       // maximum dot radius/pixel size

/* ========== DOM + contexts ========== */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const tooltip = document.getElementById('tooltip');
const loadingEl = document.getElementById('loading');
const debugEl = document.getElementById('debug-info');
const statsEl = document.getElementById('stats');
const clusterListEl = document.getElementById('cluster-list');
document.getElementById('resetBtn').addEventListener('click', resetView);
document.getElementById('showAllBtn').addEventListener('click', () => { selectedCluster = null; rebuildRaster(); });
document.getElementById('forceBtn').addEventListener('click', () => { scheduleRasterRender(10); });

/* ========== STATE ========== */
let metadata = null;
let loadedChunks = new Map(); // file -> points[]
let visiblePoints = [];       // flattened points inside current worldRect used for hover and raster draw (filtered)
let clusterColor = {};       // clusterId -> color string
let selectedCluster = null;

let camera = { x: 0, y: 0, zoom: 1 };
let isDragging = false, dragStart = { x:0, y:0 };
let mouse = { clientX:0, clientY:0, screenX:0, screenY:0 };
let hoveredPoint = null;
let selectedPoint = null; // clicked persistent highlight
let tooltipPinned = false;

/* Raster object:
   { canvas, worldRect: {x_min,x_max,y_min,y_max}, pixelsPerWorldUnit, createdAtZoom, computedDotSizePx, avgPixelSpacing }
*/
let raster = null;
let rasterRenderTimer = null;

/* Render scheduling */
let renderScheduled = false;
function scheduleRender() {
  if (!renderScheduled) { renderScheduled = true; requestAnimationFrame(() => { renderScheduled = false; render(); }); }
}

/* ========== UTIL: transforms ========== */
function resizeCanvas() {
  const container = document.getElementById('canvas-container');
  canvas.width = Math.round(container.clientWidth);
  canvas.height = Math.round(container.clientHeight);
  scheduleRender();
}

function screenToWorld(sx, sy) {
  return {
    x: (sx - canvas.width/2) / camera.zoom + camera.x,
    y: (sy - canvas.height/2) / camera.zoom + camera.y
  };
}

function worldToScreen(wx, wy) {
  return {
    x: (wx - camera.x) * camera.zoom + canvas.width/2,
    y: (wy - camera.y) * camera.zoom + canvas.height/2
  };
}

function getViewportBounds() {
  const a = screenToWorld(0,0), b = screenToWorld(canvas.width, canvas.height);
  return { x_min: Math.min(a.x,b.x), x_max: Math.max(a.x,b.x), y_min: Math.min(a.y,b.y), y_max: Math.max(a.y,b.y) };
}
function rectContains(a,b){ return a.x_min<=b.x_min && a.x_max>=b.x_max && a.y_min<=b.y_min && a.y_max>=b.y_max; }
function rectIntersects(a,b){ return !(a.x_max < b.x_min || a.x_min > b.x_max || a.y_max < b.y_min || a.y_min > b.y_max); }

/* ========== LOAD METADATA & SETUP ========== */
async function loadMetadata() {
  try {
    const r = await fetch('metadata.json');
    metadata = await r.json();
    statsEl.innerHTML = `<div><strong>${metadata.total_points.toLocaleString()}</strong> posts</div>
                         <div><strong>${metadata.num_clusters}</strong> clusters</div>`;

    // precompute cluster colors
    const COLORS = [
      '#e6194B','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4','#42d4f4','#f032e6',
      '#bfef45','#fabed4','#469990','#dcbeff','#9A6324','#fffac8','#800000','#aaffc3',
      '#808000','#ffd8b1','#000075','#a9a9a9'
    ];
    metadata.clusters.forEach((c, idx) => {
      clusterColor[c.id] = COLORS[idx % COLORS.length];
      const div = document.createElement('div');
      div.className = 'cluster-item'; div.dataset.clusterId = c.id;
      div.innerHTML = `<div class="cluster-name"><span class="color-swatch" style="background:${clusterColor[c.id]}"></span>${c.name}</div>
                        <div class="cluster-count">${c.count.toLocaleString()} posts</div>`;
      div.addEventListener('click', () => { selectedCluster = (selectedCluster===c.id? null : c.id); document.querySelectorAll('.cluster-item').forEach(it=>it.classList.toggle('active', parseInt(it.dataset.clusterId)===selectedCluster)); rebuildRaster(); });
      clusterListEl.appendChild(div);
    });

    loadingEl.style.display = 'none';
    fitToView();
    await loadVisibleChunks(); // schedule raster creation after initial chunk load
  } catch (err) {
    loadingEl.textContent = 'Error loading metadata: ' + err.message;
    console.error(err);
  }
}

/* ========== CHUNK LOADING & VISIBLE POINTS ========== */
async function loadVisibleChunks() {
  if (!metadata) return;
  const view = getViewportBounds();
  const toLoad = [];

  // expand search area a bit to pre-load neighboring chunks
  const padX = (view.x_max - view.x_min) * 0.5;
  const padY = (view.y_max - view.y_min) * 0.5;
  const searchRect = { x_min: view.x_min - padX, x_max: view.x_max + padX, y_min: view.y_min - padY, y_max: view.y_max + padY };

  for (const chunk of metadata.chunks) {
    if (rectIntersects(chunk.bounds, searchRect) && !loadedChunks.has(chunk.file)) toLoad.push(chunk.file);
  }

  // limited concurrency fetch
  const CONCURRENCY = 6;
  let idx = 0;
  async function workerFetch() {
    while (idx < toLoad.length) {
      const i = idx++;
      const file = toLoad[i];
      try {
        const r = await fetch(file);
        const data = await r.json();
        loadedChunks.set(file, data);
      } catch (err) {
        console.error('load chunk failed', file, err);
      }
    }
  }
  const workers = Array.from({length: Math.min(CONCURRENCY, toLoad.length)}, workerFetch);
  await Promise.all(workers);

  updateDebugInfo();
  rebuildVisiblePoints();
  if (!raster) scheduleRasterRender(60); else scheduleRasterRender(RASTER_DEBOUNCE_MS);
  scheduleRender();
}

/* Flatten visible points from loadedChunks */
function rebuildVisiblePoints() {
  visiblePoints = [];
  const worldRect = raster ? raster.worldRect : getViewportBounds();
  // If raster exists, use its worldRect (we draw from raster area). Otherwise use current viewport padded.
  const padW = (worldRect.x_max - worldRect.x_min) * 0.5;
  const padH = (worldRect.y_max - worldRect.y_min) * 0.5;
  const filterRect = { x_min: worldRect.x_min - padW, x_max: worldRect.x_max + padW, y_min: worldRect.y_min - padH, y_max: worldRect.y_max + padH };

  for (const pts of loadedChunks.values()) {
    for (const p of pts) {
      if (selectedCluster !== null && p.cluster !== selectedCluster) continue;
      if (p.x < filterRect.x_min || p.x > filterRect.x_max || p.y < filterRect.y_min || p.y > filterRect.y_max) continue;
      visiblePoints.push(p);
      if (visiblePoints.length >= VISIBLE_POINTS_CAP) break;
    }
    if (visiblePoints.length >= VISIBLE_POINTS_CAP) break;
  }
}

/* ========== RASTER CREATION & ADAPTIVE DOT SIZE ========== */
function scheduleRasterRender(ms = RASTER_DEBOUNCE_MS) {
  if (rasterRenderTimer) clearTimeout(rasterRenderTimer);
  rasterRenderTimer = setTimeout(() => { rasterRenderTimer = null; createRasterForCurrentView(); }, ms);
}
function forceRaster() { scheduleRasterRender(10); }

function needsRasterRecreate() {
  if (!raster) return true;
  const view = getViewportBounds();
  if (!rectContains(raster.worldRect, view)) return true;
  const currentPPWU = camera.zoom * DPR;
  if (currentPPWU > raster.pixelsPerWorldUnit * ZOOM_RENDER_THRESHOLD) return true;
  const zf = camera.zoom / (raster.createdAtZoom || camera.zoom);
  if (zf > ZOOM_FACTOR_THRESHOLD || zf < 1/ZOOM_FACTOR_THRESHOLD) return true;
  return false;
}

function rebuildRaster() {
  raster = null;
  visiblePoints = [];
  scheduleRasterRender(40);
  loadVisibleChunks();
}

/* Create raster using visiblePoints and compute adaptive dot size */
function createRasterForCurrentView() {
  if (!metadata) return;
  if (loadedChunks.size === 0) { scheduleRasterRender(150); return; } // wait for chunks

  const view = getViewportBounds();
  const w = view.x_max - view.x_min, h = view.y_max - view.y_min;
  const padW = w * ((RASTER_PAD - 1) / 2), padH = h * ((RASTER_PAD - 1) / 2);
  const worldRect = { x_min: view.x_min - padW, x_max: view.x_max + padW, y_min: view.y_min - padH, y_max: view.y_max + padH };

  // pixels per world unit at creation
  let ppwu = camera.zoom * DPR;
  let rasterW = Math.max(2, Math.round((worldRect.x_max - worldRect.x_min) * ppwu));
  let rasterH = Math.max(2, Math.round((worldRect.y_max - worldRect.y_min) * ppwu));

  // clamp
  if (rasterW > MAX_RASTER_DIM || rasterH > MAX_RASTER_DIM) {
    const scaleClamp = Math.min(MAX_RASTER_DIM / rasterW, MAX_RASTER_DIM / rasterH);
    ppwu = ppwu * scaleClamp;
    rasterW = Math.max(MIN_RASTER_DIM, Math.round((worldRect.x_max - worldRect.x_min) * ppwu));
    rasterH = Math.max(MIN_RASTER_DIM, Math.round((worldRect.y_max - worldRect.y_min) * ppwu));
  }

  // gather visiblePoints (strictly within worldRect) - replace visiblePoints with this set
  visiblePoints = [];
  for (const pts of loadedChunks.values()) {
    for (const p of pts) {
      if (selectedCluster !== null && p.cluster !== selectedCluster) continue;
      if (p.x < worldRect.x_min || p.x > worldRect.x_max || p.y < worldRect.y_min || p.y > worldRect.y_max) continue;
      visiblePoints.push(p);
      if (visiblePoints.length >= VISIBLE_POINTS_CAP) break;
    }
    if (visiblePoints.length >= VISIBLE_POINTS_CAP) break;
  }

  const n = visiblePoints.length || 1;
  const worldArea = (worldRect.x_max - worldRect.x_min) * (worldRect.y_max - worldRect.y_min);

  // Cheap expected spacing heuristic:
  // average distance between points (world units) ≈ sqrt(area / n)
  const avgSpacingWorld = Math.sqrt(worldArea / n);
  const avgPixelSpacing = avgSpacingWorld * ppwu;

  // Adaptive dot size (in pixels). Use a fraction of avg spacing so dots are visible but don't completely overlap.
  // Tune DOT_FRACTION / DOT_MIN_PX / DOT_MAX_PX above.
  let dotSizePx = Math.round(avgPixelSpacing * DOT_FRACTION);
  dotSizePx = Math.max(DOT_MIN_PX, Math.min(DOT_MAX_PX, dotSizePx));

  // If the dataset is extremely sparse such that avgPixelSpacing < 1, ensure a minimal visible size
  if (dotSizePx < DOT_MIN_PX) dotSizePx = DOT_MIN_PX;

  // create offscreen canvas
  const off = document.createElement('canvas');
  off.width = rasterW;
  off.height = rasterH;
  const oc = off.getContext('2d', { alpha: false });

  // background
  oc.fillStyle = '#070707';
  oc.fillRect(0,0,off.width,off.height);

  // draw points quickly using fillRect squares sized to dotSizePx
  // compute sample skipping if too many points
  const sampleFactor = visiblePoints.length > VISIBLE_POINTS_CAP ? (visiblePoints.length / VISIBLE_POINTS_CAP) : 1;
  const step = Math.max(1, Math.ceil(sampleFactor));

  // place squares centered: we compute halfsize
  const half = Math.max(1, Math.floor(dotSizePx / 2));

  for (let i=0; i<visiblePoints.length; i+=step) {
    const p = visiblePoints[i];
    const px = Math.round((p.x - worldRect.x_min) * ppwu);
    const py = Math.round((p.y - worldRect.y_min) * ppwu);
    oc.fillStyle = clusterColor[p.cluster] || '#ffffff';
    // draw centered rectangle
    oc.fillRect(px - half, py - half, dotSizePx, dotSizePx);
  }

  raster = {
    canvas: off,
    worldRect,
    pixelsPerWorldUnit: ppwu,
    createdAtZoom: camera.zoom,
    computedDotSizePx: dotSizePx,
    avgPixelSpacing
  };

  // render now
  scheduleRender();
  updateDebugInfo();
}

/* ========== RENDER: draw raster + overlays ========== */
function render() {
  // clear
  ctx.fillStyle = '#070707';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // schedule raster if necessary (but do not check constantly elsewhere)
  if (needsRasterRecreate()) {
    scheduleRasterRender(60);
  }

  if (raster) {
    const tl = worldToScreen(raster.worldRect.x_min, raster.worldRect.y_min);
    const br = worldToScreen(raster.worldRect.x_max, raster.worldRect.y_max);
    const dx = tl.x, dy = tl.y, dw = br.x - tl.x, dh = br.y - tl.y;
    try {
      ctx.drawImage(raster.canvas, dx, dy, dw, dh);
    } catch (err) {
      console.error('drawImage failed', err);
      raster = null;
      scheduleRasterRender(200);
    }
  } else {
    drawPointsDirectly(100000);
  }

  // hovered soft highlight
  if (hoveredPoint) {
    const s = worldToScreen(hoveredPoint.x, hoveredPoint.y);
    ctx.strokeStyle = 'rgba(255,255,255,0.9)';
    ctx.lineWidth = Math.max(1, 2);
    // make highlight scale with computed dot size (if available) or with camera zoom
    const base = raster ? Math.max(6, Math.round(raster.computedDotSizePx * 1.8)) : Math.max(6, 6 * Math.min(1, camera.zoom));
    ctx.beginPath();
    ctx.arc(s.x, s.y, base, 0, Math.PI*2);
    ctx.stroke();
  }

  // persistent selected highlight
  if (selectedPoint) {
    const s = worldToScreen(selectedPoint.x, selectedPoint.y);
    ctx.strokeStyle = '#ffcc00';
    ctx.lineWidth = 2;
    const base = raster ? Math.max(8, Math.round(raster.computedDotSizePx * 2.2)) : 8;
    ctx.beginPath();
    ctx.arc(s.x, s.y, base, 0, Math.PI*2);
    ctx.stroke();
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath();
    ctx.arc(s.x, s.y, Math.max(2, Math.round((raster ? raster.computedDotSizePx : 2) * 0.35)), 0, Math.PI*2);
    ctx.fill();
  }
}

/* cheap direct draw fallback (limits number of points drawn) */
function drawPointsDirectly(maxPoints=50000) {
  // compute approximate dot size using viewport and visiblePoints
  const view = getViewportBounds();
  const worldW = view.x_max - view.x_min, worldH = view.y_max - view.y_min;
  const n = Math.max(1, visiblePoints.length);
  const avgSpacingWorld = Math.sqrt((worldW * worldH) / n);
  const avgPixelSpacing = avgSpacingWorld * camera.zoom;
  let dotSizePx = Math.round(avgPixelSpacing * DOT_FRACTION);
  dotSizePx = Math.max(DOT_MIN_PX, Math.min(DOT_MAX_PX, dotSizePx));
  const half = Math.max(1, Math.floor(dotSizePx / 2));

  let count = 0;
  for (const pts of loadedChunks.values()) {
    for (const p of pts) {
      if (selectedCluster !== null && p.cluster !== selectedCluster) continue;
      const s = worldToScreen(p.x,p.y);
      if (s.x < -8 || s.x > canvas.width+8 || s.y < -8 || s.y > canvas.height+8) continue;
      ctx.fillStyle = clusterColor[p.cluster] || '#fff';
      // draw square or small circle
      ctx.fillRect(s.x - half, s.y - half, dotSizePx, dotSizePx);
      if (++count >= maxPoints) return;
    }
  }
}

/* ========== INTERACTIONS: pan, zoom, hover, click ========== */
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

canvas.addEventListener('mousedown', (e) => {
  isDragging = true; dragStart = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mousemove', (e) => {
  mouse.clientX = e.clientX; mouse.clientY = e.clientY;
  const rect = canvas.getBoundingClientRect();
  mouse.screenX = e.clientX - rect.left; mouse.screenY = e.clientY - rect.top;

  if (isDragging) {
    const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
    camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom;
    dragStart = { x: e.clientX, y: e.clientY };
    scheduleLoadAfterPan();
    scheduleRender();
  } else {
    scheduleHoverCheck();
  }
});

canvas.addEventListener('mouseup', (e) => { isDragging = false; });
canvas.addEventListener('mouseleave', () => { isDragging = false; if (!tooltipPinned) { tooltip.style.display='none'; hoveredPoint=null; scheduleRender(); } });

canvas.addEventListener('click', (e) => {
  if (isDragging) return;
  if (hoveredPoint) {
    tooltipPinned = !tooltipPinned;
    tooltip.classList.toggle('pinned', tooltipPinned);
    if (tooltipPinned) {
      selectedPoint = hoveredPoint;
      showPinnedTooltip(hoveredPoint);
    } else {
      selectedPoint = null; tooltip.style.display='none';
    }
    scheduleRender();
  } else {
    if (tooltipPinned) { tooltipPinned = false; tooltip.classList.remove('pinned'); }
    selectedPoint = null; tooltip.style.display='none'; scheduleRender();
  }
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left, my = e.clientY - rect.top;
  const before = screenToWorld(mx, my);
  const zoomFactor = e.deltaY < 0 ? 1.12 : 0.88;
  camera.zoom = Math.max(0.01, Math.min(2000, camera.zoom * zoomFactor));
  const after = screenToWorld(mx, my);
  camera.x += before.x - after.x; camera.y += before.y - after.y;

  loadVisibleChunks();
  if (needsRasterRecreate()) scheduleRasterRender(60);
  scheduleRender();
}, { passive:false });

/* ========== hover scheduling & finding nearest ========== */
let hoverCheckScheduled = false;
function scheduleHoverCheck() {
  if (hoverCheckScheduled) return;
  hoverCheckScheduled = true;
  requestAnimationFrame(() => { hoverCheckScheduled = false; doHoverCheck(); });
}

function doHoverCheck() {
  const rect = canvas.getBoundingClientRect();
  const world = screenToWorld(mouse.screenX, mouse.screenY);
  const thresholdWorld = HOVER_THRESHOLD_PX / Math.max(1, camera.zoom);
  let nearest = null, best = thresholdWorld * thresholdWorld;

  const n = Math.min(visiblePoints.length, HOVER_SEARCH_CAP);
  for (let i=0; i<n; ++i) {
    const p = visiblePoints[i];
    const dx = p.x - world.x, dy = p.y - world.y;
    const d2 = dx*dx + dy*dy;
    if (d2 < best) { best = d2; nearest = p; }
  }

  if (nearest !== hoveredPoint) {
    hoveredPoint = nearest;
    if (!tooltipPinned) {
      if (hoveredPoint) showHoverTooltip(hoveredPoint, mouse.clientX, mouse.clientY); else tooltip.style.display='none';
    }
    scheduleRender();
  } else if (hoveredPoint) {
    if (!tooltipPinned) { tooltip.style.left = (mouse.clientX + 12) + 'px'; tooltip.style.top = (mouse.clientY + 12) + 'px'; }
  }
}

/* ========== Tooltip helpers ========== */
function showHoverTooltip(pt, clientX, clientY) {
  const clusterName = metadata.clusters.find(c=>c.id===pt.cluster)?.name || 'Unknown';
  tooltip.innerHTML = `<strong>${pt.title}</strong><br><span style="color:#888;">Cluster: ${clusterName}</span>
    <a href="https://news.ycombinator.com/item?id=${pt.id}" target="_blank">View on HN ↗</a>
    <div style="margin-top:8px;font-size:10px;color:#666;">Click to pin tooltip</div>`;
  tooltip.style.left = (clientX + 12) + 'px';
  tooltip.style.top = (clientY + 12) + 'px';
  tooltip.style.display = 'block';
}
function showPinnedTooltip(pt) {
  const clusterName = metadata.clusters.find(c=>c.id===pt.cluster)?.name || 'Unknown';
  tooltip.innerHTML = `<strong>${pt.title}</strong><br><span style="color:#888;">Cluster: ${clusterName}</span>
    <a href="https://news.ycombinator.com/item?id=${pt.id}" target="_blank">View on HN ↗</a>
    <div style="margin-top:8px;font-size:10px;color:#666;">Click again to unpin</div>`;
  const s = worldToScreen(pt.x, pt.y);
  tooltip.style.left = Math.min(window.innerWidth - 440, s.x + 12) + 'px';
  tooltip.style.top = Math.min(window.innerHeight - 160, s.y + 12) + 'px';
  tooltip.style.display = 'block';
}

/* ========== Pan debounce (load & raster triggers) ========== */
let panLoadTimer = null;
function scheduleLoadAfterPan(ms = 150) {
  if (panLoadTimer) clearTimeout(panLoadTimer);
  panLoadTimer = setTimeout(() => { panLoadTimer = null; loadVisibleChunks(); if (needsRasterRecreate()) scheduleRasterRender(120); }, ms);
}

/* ========== Debug UI ========== */
function updateDebugInfo() {
  const totalPoints = Array.from(loadedChunks.values()).reduce((s,arr)=>s+arr.length,0);
  debugEl.textContent = `Loaded: ${loadedChunks.size}/${metadata ? metadata.chunks.length : 0} chunks (${totalPoints.toLocaleString()} pts). VisiblePoints: ${visiblePoints.length.toLocaleString()}`;
}

/* ========== View helpers ========== */
function fitToView() {
  if (!metadata) return;
  const b = metadata.bounds;
  const rx = b.x_max - b.x_min, ry = b.y_max - b.y_min;
  const padding = 1.15;
  const zoomX = (canvas.width / (rx * padding));
  const zoomY = (canvas.height / (ry * padding));
  camera.zoom = Math.min(zoomX, zoomY);
  camera.x = (b.x_min + b.x_max) / 2;
  camera.y = (b.y_min + b.y_max) / 2;
  raster = null; visiblePoints = [];
  scheduleRasterRender(30);
}
function resetView(){ fitToView(); }

/* ========== START ========== */
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
loadMetadata();
window.addEventListener('keydown', (e)=>{ if(e.key==='r') scheduleRasterRender(10); if(e.key==='0') resetView(); });
</script>
</body>
</html>
